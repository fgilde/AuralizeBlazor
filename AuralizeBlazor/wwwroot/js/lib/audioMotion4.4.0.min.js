const VERSION = "4.4.0", PI = Math.PI, TAU = 2 * PI, HALF_PI = PI / 2, C_1 = 8.17579892, CANVAS_BACKGROUND_COLOR = "#000", CHANNEL_COMBINED = "dual-combined", CHANNEL_HORIZONTAL = "dual-horizontal", CHANNEL_SINGLE = "single", CHANNEL_VERTICAL = "dual-vertical", COLOR_BAR_INDEX = "bar-index", COLOR_BAR_LEVEL = "bar-level", COLOR_GRADIENT = "gradient", DEBOUNCE_TIMEOUT = 60, EVENT_CLICK = "click", EVENT_FULLSCREENCHANGE = "fullscreenchange", EVENT_RESIZE = "resize", GRADIENT_DEFAULT_BGCOLOR = "#111", FILTER_NONE = "", FILTER_A = "A", FILTER_B = "B", FILTER_C = "C", FILTER_D = "D", FILTER_468 = "468", FONT_FAMILY = "sans-serif", FPS_COLOR = "#0f0", LEDS_UNLIT_COLOR = "#7f7f7f22", MODE_GRAPH = 10, REASON_CREATE = "create", REASON_FSCHANGE = "fschange", REASON_LORES = "lores", REASON_RESIZE = "resize", REASON_USER = "user", SCALEX_BACKGROUND_COLOR = "#000c", SCALEX_LABEL_COLOR = "#fff", SCALEX_HIGHLIGHT_COLOR = "#4f4", SCALEY_LABEL_COLOR = "#888", SCALEY_MIDLINE_COLOR = "#555", SCALE_BARK = "bark", SCALE_LINEAR = "linear", SCALE_LOG = "log", SCALE_MEL = "mel", PRISM = ["#a35", "#c66", "#e94", "#ed0", "#9d5", "#4d8", "#2cb", "#0bc", "#09c", "#36b"], GRADIENTS = [["classic", { colorStops: ["red", { color: "yellow", level: .85, pos: .6 }, { color: "lime", level: .475 }] }], ["prism", { colorStops: PRISM }], ["rainbow", { dir: "h", colorStops: ["#817", ...PRISM, "#639"] }], ["orangered", { bgColor: "#3e2f29", colorStops: ["OrangeRed"] }], ["steelblue", { bgColor: "#222c35", colorStops: ["SteelBlue"] }]], DEFAULT_SETTINGS = { alphaBars: !1, ansiBands: !1, barSpace: .1, bgAlpha: .7, channelLayout: "single", colorMode: "gradient", fftSize: 8192, fillAlpha: 1, frequencyScale: "log", gradient: GRADIENTS[0][0], height: void 0, ledBars: !1, linearAmplitude: !1, linearBoost: 1, lineWidth: 0, loRes: !1, lumiBars: !1, maxDecibels: -25, maxFPS: 0, maxFreq: 22e3, minDecibels: -85, minFreq: 20, mirror: 0, mode: 0, noteLabels: !1, outlineBars: !1, overlay: !1, peakLine: !1, radial: !1, radialInvert: !1, radius: .3, reflexAlpha: .15, reflexBright: 1, reflexFit: !0, reflexRatio: 0, roundBars: !1, showBgColor: !0, showFPS: !1, showPeaks: !0, showScaleX: !0, showScaleY: !1, smoothing: .5, spinSpeed: 0, splitGradient: !1, start: !0, trueLeds: !1, useCanvas: !0, volume: 1, weightingFilter: "", width: void 0 }, ERR_AUDIO_CONTEXT_FAIL = ["ERR_AUDIO_CONTEXT_FAIL", "Could not create audio context. Web Audio API not supported?"], ERR_INVALID_AUDIO_CONTEXT = ["ERR_INVALID_AUDIO_CONTEXT", "Provided audio context is not valid"], ERR_UNKNOWN_GRADIENT = ["ERR_UNKNOWN_GRADIENT", "Unknown gradient"], ERR_FREQUENCY_TOO_LOW = ["ERR_FREQUENCY_TOO_LOW", "Frequency values must be >= 1"], ERR_INVALID_MODE = ["ERR_INVALID_MODE", "Invalid mode"], ERR_REFLEX_OUT_OF_RANGE = ["ERR_REFLEX_OUT_OF_RANGE", "Reflex ratio must be >= 0 and < 1"], ERR_INVALID_AUDIO_SOURCE = ["ERR_INVALID_AUDIO_SOURCE", "Audio source must be an instance of HTMLMediaElement or AudioNode"], ERR_GRADIENT_INVALID_NAME = ["ERR_GRADIENT_INVALID_NAME", "Gradient name must be a non-empty string"], ERR_GRADIENT_NOT_AN_OBJECT = ["ERR_GRADIENT_NOT_AN_OBJECT", "Gradient options must be an object"], ERR_GRADIENT_MISSING_COLOR = ["ERR_GRADIENT_MISSING_COLOR", "Gradient colorStops must be a non-empty array"]; class AudioMotionError extends Error { constructor(t, e) { const [i, s] = t; super(s + (void 0 !== e ? `: ${e}` : "")), this.name = "AudioMotionError", this.code = i } } const deprecate = (t, e) => console.warn(`${t} is deprecated. Use ${e} instead.`), isEmpty = t => { for (const e in t) return !1; return !0 }, validateFromList = (t, e, i = "toLowerCase") => e[Math.max(0, e.indexOf(("" + t)[i]()))], findY = (t, e, i, s, r) => e + (s - e) * (r - t) / (i - t); Array.prototype.findLastIndex || (Array.prototype.findLastIndex = function (t) { let e = this.length; for (; e-- > 0;)if (t(this[e])) return e; return -1 }); export default class AudioMotionAnalyzer { constructor(t, e = {}) { this._ready = !1, this._aux = {}, this._canvasGradients = [], this._destroyed = !1, this._energy = { val: 0, peak: 0, hold: 0 }, this._flg = {}, this._fps = 0, this._gradients = {}, this._last = 0, this._outNodes = [], this._ownContext = !1, this._selectedGrads = [], this._sources = [], t instanceof Element || (isEmpty(e) && !isEmpty(t) && (e = t), t = null), this._ownCanvas = !(e.canvas instanceof HTMLCanvasElement); const i = this._ownCanvas ? document.createElement("canvas") : e.canvas; i.style = "max-width: 100%;", this._ctx = i.getContext("2d"); for (const [t, e] of GRADIENTS) this.registerGradient(t, e); let s; if (this._container = t || !this._ownCanvas && i.parentElement || document.body, this._defaultWidth = this._container.clientWidth || 640, this._defaultHeight = this._container.clientHeight || 270, e.source && (s = e.source.context)); else if (s = e.audioCtx); else try { s = new (window.AudioContext || window.webkitAudioContext), this._ownContext = !0 } catch (t) { throw new AudioMotionError(ERR_AUDIO_CONTEXT_FAIL) } if (!s.createGain) throw new AudioMotionError(ERR_INVALID_AUDIO_CONTEXT); const r = this._analyzer = [s.createAnalyser(), s.createAnalyser()], a = this._splitter = s.createChannelSplitter(2), n = this._merger = s.createChannelMerger(2); this._input = s.createGain(), this._output = s.createGain(), e.source && this.connectInput(e.source); for (const t of [0, 1]) a.connect(r[t], t); n.connect(this._output), !1 !== e.connectSpeakers && this.connectOutput(); for (const t of ["_scaleX", "_scaleR"]) this[t] = document.createElement("canvas").getContext("2d"); this._fsEl = e.fsElement || i; const o = () => { this._fsTimeout || (this._fsTimeout = window.setTimeout((() => { this._fsChanging || (this._setCanvas("resize"), this._fsTimeout = 0) }), 60)) }; window.ResizeObserver && (this._observer = new ResizeObserver(o), this._observer.observe(this._container)), this._controller = new AbortController; const l = this._controller.signal; window.addEventListener("resize", o, { signal: l }), i.addEventListener("fullscreenchange", (() => { this._fsChanging = !0, this._fsTimeout && window.clearTimeout(this._fsTimeout), this._setCanvas("fschange"), this._fsTimeout = window.setTimeout((() => { this._fsChanging = !1, this._fsTimeout = 0 }), 60) }), { signal: l }); const h = () => { "suspended" == s.state && s.resume(), window.removeEventListener("click", h) }; window.addEventListener("click", h), document.addEventListener("visibilitychange", (() => { "hidden" != document.visibilityState && (this._frames = 0, this._time = performance.now()) }), { signal: l }), this._setProps(e, !0), this.useCanvas && this._ownCanvas && this._container.appendChild(i), this._ready = !0, this._setCanvas("create") } get alphaBars() { return this._alphaBars } set alphaBars(t) { this._alphaBars = !!t, this._calcBars() } get ansiBands() { return this._ansiBands } set ansiBands(t) { this._ansiBands = !!t, this._calcBars() } get barSpace() { return this._barSpace } set barSpace(t) { this._barSpace = +t || 0, this._calcBars() } get channelLayout() { return this._chLayout } set channelLayout(t) { this._chLayout = validateFromList(t, ["single", "dual-horizontal", "dual-vertical", "dual-combined"]), this._input.disconnect(), this._input.connect("single" != this._chLayout ? this._splitter : this._analyzer[0]), this._analyzer[0].disconnect(), this._outNodes.length && this._analyzer[0].connect("single" != this._chLayout ? this._merger : this._output), this._calcBars(), this._makeGrad() } get colorMode() { return this._colorMode } set colorMode(t) { this._colorMode = validateFromList(t, ["gradient", "bar-index", "bar-level"]) } get fftSize() { return this._analyzer[0].fftSize } set fftSize(t) { for (const e of [0, 1]) this._analyzer[e].fftSize = t; const e = this._analyzer[0].frequencyBinCount; this._fftData = [new Float32Array(e), new Float32Array(e)], this._calcBars() } get frequencyScale() { return this._frequencyScale } set frequencyScale(t) { this._frequencyScale = validateFromList(t, ["log", "bark", "mel", "linear"]), this._calcBars() } get gradient() { return this._selectedGrads[0] } set gradient(t) { this._setGradient(t) } get gradientLeft() { return this._selectedGrads[0] } set gradientLeft(t) { this._setGradient(t, 0) } get gradientRight() { return this._selectedGrads[1] } set gradientRight(t) { this._setGradient(t, 1) } get height() { return this._height } set height(t) { this._height = t, this._setCanvas("user") } get ledBars() { return this._showLeds } set ledBars(t) { this._showLeds = !!t, this._calcBars() } get linearAmplitude() { return this._linearAmplitude } set linearAmplitude(t) { this._linearAmplitude = !!t } get linearBoost() { return this._linearBoost } set linearBoost(t) { this._linearBoost = t >= 1 ? +t : 1 } get lineWidth() { return this._lineWidth } set lineWidth(t) { this._lineWidth = +t || 0 } get loRes() { return this._loRes } set loRes(t) { this._loRes = !!t, this._setCanvas("lores") } get lumiBars() { return this._lumiBars } set lumiBars(t) { this._lumiBars = !!t, this._calcBars(), this._makeGrad() } get maxDecibels() { return this._analyzer[0].maxDecibels } set maxDecibels(t) { for (const e of [0, 1]) this._analyzer[e].maxDecibels = t } get maxFPS() { return this._maxFPS } set maxFPS(t) { this._maxFPS = t < 0 ? 0 : +t || 0 } get maxFreq() { return this._maxFreq } set maxFreq(t) { if (t < 1) throw new AudioMotionError(ERR_FREQUENCY_TOO_LOW); this._maxFreq = Math.min(t, this.audioCtx.sampleRate / 2), this._calcBars() } get minDecibels() { return this._analyzer[0].minDecibels } set minDecibels(t) { for (const e of [0, 1]) this._analyzer[e].minDecibels = t } get minFreq() { return this._minFreq } set minFreq(t) { if (t < 1) throw new AudioMotionError(ERR_FREQUENCY_TOO_LOW); this._minFreq = +t, this._calcBars() } get mirror() { return this._mirror } set mirror(t) { this._mirror = 0 | Math.sign(t), this._calcBars(), this._makeGrad() } get mode() { return this._mode } set mode(t) { const e = 0 | t; if (!(e >= 0 && e <= 10 && 9 != e)) throw new AudioMotionError(ERR_INVALID_MODE, t); this._mode = e, this._calcBars(), this._makeGrad() } get noteLabels() { return this._noteLabels } set noteLabels(t) { this._noteLabels = !!t, this._createScales() } get outlineBars() { return this._outlineBars } set outlineBars(t) { this._outlineBars = !!t, this._calcBars() } get peakLine() { return this._peakLine } set peakLine(t) { this._peakLine = !!t } get radial() { return this._radial } set radial(t) { this._radial = !!t, this._calcBars(), this._makeGrad() } get radialInvert() { return this._radialInvert } set radialInvert(t) { this._radialInvert = !!t, this._calcBars(), this._makeGrad() } get radius() { return this._radius } set radius(t) { this._radius = +t || 0, this._calcBars(), this._makeGrad() } get reflexRatio() { return this._reflexRatio } set reflexRatio(t) { if ((t = +t || 0) < 0 || t >= 1) throw new AudioMotionError(ERR_REFLEX_OUT_OF_RANGE); this._reflexRatio = t, this._calcBars(), this._makeGrad() } get roundBars() { return this._roundBars } set roundBars(t) { this._roundBars = !!t, this._calcBars() } get smoothing() { return this._analyzer[0].smoothingTimeConstant } set smoothing(t) { for (const e of [0, 1]) this._analyzer[e].smoothingTimeConstant = t } get spinSpeed() { return this._spinSpeed } set spinSpeed(t) { t = +t || 0, void 0 !== this._spinSpeed && 0 != t || (this._spinAngle = -HALF_PI), this._spinSpeed = t } get splitGradient() { return this._splitGradient } set splitGradient(t) { this._splitGradient = !!t, this._makeGrad() } get stereo() { return deprecate("stereo", "channelLayout"), "single" != this._chLayout } set stereo(t) { deprecate("stereo", "channelLayout"), this.channelLayout = t ? "dual-vertical" : "single" } get trueLeds() { return this._trueLeds } set trueLeds(t) { this._trueLeds = !!t } get volume() { return this._output.gain.value } set volume(t) { this._output.gain.value = t } get weightingFilter() { return this._weightingFilter } set weightingFilter(t) { this._weightingFilter = validateFromList(t, ["", "A", "B", "C", "D", "468"], "toUpperCase") } get width() { return this._width } set width(t) { this._width = t, this._setCanvas("user") } get audioCtx() { return this._input.context } get canvas() { return this._ctx.canvas } get canvasCtx() { return this._ctx } get connectedSources() { return this._sources } get connectedTo() { return this._outNodes } get fps() { return this._fps } get fsHeight() { return this._fsHeight } get fsWidth() { return this._fsWidth } get isAlphaBars() { return this._flg.isAlpha } get isBandsMode() { return this._flg.isBands } get isDestroyed() { return this._destroyed } get isFullscreen() { return this._fsEl && (document.fullscreenElement || document.webkitFullscreenElement) === this._fsEl } get isLedBars() { return this._flg.isLeds } get isLumiBars() { return this._flg.isLumi } get isOctaveBands() { return this._flg.isOctaves } get isOn() { return !!this._runId } get isOutlineBars() { return this._flg.isOutline } get pixelRatio() { return this._pixelRatio } get isRoundBars() { return this._flg.isRound } static get version() { return "4.4.0" } connectInput(t) { const e = t instanceof HTMLMediaElement; if (!e && !t.connect) throw new AudioMotionError(ERR_INVALID_AUDIO_SOURCE); const i = e ? this.audioCtx.createMediaElementSource(t) : t; return this._sources.includes(i) || (i.connect(this._input), this._sources.push(i)), i } connectOutput(t = this.audioCtx.destination) { if (!this._outNodes.includes(t) && (this._output.connect(t), this._outNodes.push(t), 1 == this._outNodes.length)) for (const t of [0, 1]) this._analyzer[t].connect("single" != this._chLayout || t ? this._merger : this._output, 0, t) } destroy() { if (!this._ready) return; const { audioCtx: t, canvas: e, _controller: i, _input: s, _merger: r, _observer: a, _ownCanvas: n, _ownContext: o, _splitter: l } = this; this._destroyed = !0, this._ready = !1, this.stop(), i.abort(), a && a.disconnect(), this.onCanvasResize = null, this.onCanvasDraw = null, this._fsEl = null, this.disconnectInput(), this.disconnectOutput(), s.disconnect(), l.disconnect(), r.disconnect(), o && t.close(), n && e.remove(), this._calcBars() } disconnectInput(t, e) { t ? Array.isArray(t) || (t = [t]) : t = Array.from(this._sources); for (const i of t) { const t = this._sources.indexOf(i); if (e && i.mediaStream) for (const t of i.mediaStream.getAudioTracks()) t.stop(); t >= 0 && (i.disconnect(this._input), this._sources.splice(t, 1)) } } disconnectOutput(t) { if ((!t || this._outNodes.includes(t)) && (this._output.disconnect(t), this._outNodes = t ? this._outNodes.filter((e => e !== t)) : [], 0 == this._outNodes.length)) for (const t of [0, 1]) this._analyzer[t].disconnect() } getBars() { return Array.from(this._bars, (({ posX: t, freq: e, freqLo: i, freqHi: s, hold: r, peak: a, value: n }) => ({ posX: t, freq: e, freqLo: i, freqHi: s, hold: r, peak: a, value: n }))) } getEnergy(t, e) { if (void 0 === t) return this._energy.val; if (t != +t) { if ("peak" == t) return this._energy.peak; const i = { bass: [20, 250], lowMid: [250, 500], mid: [500, 2e3], highMid: [2e3, 4e3], treble: [4e3, 16e3] }; if (!i[t]) return null;[t, e] = i[t] } const i = this._freqToBin(t), s = e ? this._freqToBin(e) : i, r = "single" == this._chLayout ? 1 : 2; let a = 0; for (let t = 0; t < r; t++)for (let e = i; e <= s; e++)a += this._normalizedB(this._fftData[t][e]); return a / (s - i + 1) / r } getOptions(t) { Array.isArray(t) || (t = [t]); let e = {}; for (const i of Object.keys(DEFAULT_SETTINGS)) t.includes(i) || ("gradient" == i && this.gradientLeft != this.gradientRight ? (e.gradientLeft = this.gradientLeft, e.gradientRight = this.gradientRight) : "start" != i && (e[i] = this[i])); return e } registerGradient(t, e) { if ("string" != typeof t || 0 == t.trim().length) throw new AudioMotionError(ERR_GRADIENT_INVALID_NAME); if ("object" != typeof e) throw new AudioMotionError(ERR_GRADIENT_NOT_AN_OBJECT); const { colorStops: i } = e; if (!Array.isArray(i) || !i.length) throw new AudioMotionError(ERR_GRADIENT_MISSING_COLOR); const s = i.length, r = t => +t != t || t < 0 || t > 1; i.forEach(((t, e) => { const a = e / Math.max(1, s - 1); "object" != typeof t ? i[e] = { pos: a, color: t } : r(t.pos) && (t.pos = a), r(t.level) && (i[e].level = 1 - e / s) })), i.sort(((t, e) => t.level < e.level ? 1 : t.level > e.level ? -1 : 0)), i[0].level = 1, this._gradients[t] = { bgColor: e.bgColor || "#111", dir: e.dir, colorStops: i }, this._selectedGrads.includes(t) && this._makeGrad() } setCanvasSize(t, e) { this._width = t, this._height = e, this._setCanvas("user") } setFreqRange(t, e) { if (t < 1 || e < 1) throw new AudioMotionError(ERR_FREQUENCY_TOO_LOW); this._minFreq = Math.min(t, e), this.maxFreq = Math.max(t, e) } setLedParams(t) { let e, i, s; t && (e = 0 | t.maxLeds, i = +t.spaceV, s = +t.spaceH), this._ledParams = e > 0 && i > 0 && s >= 0 ? [e, i, s] : void 0, this._calcBars() } setOptions(t) { this._setProps(t) } setSensitivity(t, e) { for (const i of [0, 1]) this._analyzer[i].minDecibels = Math.min(t, e), this._analyzer[i].maxDecibels = Math.max(t, e) } start() { this.toggleAnalyzer(!0) } stop() { this.toggleAnalyzer(!1) } toggleAnalyzer(t) { const e = this.isOn; return void 0 === t && (t = !e), e && !t ? (cancelAnimationFrame(this._runId), this._runId = 0) : e || !t || this._destroyed || (this._frames = 0, this._time = performance.now(), this._runId = requestAnimationFrame((t => this._draw(t)))), this.isOn } toggleFullscreen() { if (this.isFullscreen) document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullscreen && document.webkitExitFullscreen(); else { const t = this._fsEl; if (!t) return; t.requestFullscreen ? t.requestFullscreen() : t.webkitRequestFullscreen && t.webkitRequestFullscreen() } } _binToFreq(t) { return t * this.audioCtx.sampleRate / this.fftSize || 1 } _calcBars() { const t = this._bars = []; if (!this._ready) return void (this._flg = { isAlpha: !1, isBands: !1, isLeds: !1, isLumi: !1, isOctaves: !1, isOutline: !1, isRound: !1, noLedGap: !1 }); const { _ansiBands: e, _barSpace: i, canvas: s, _chLayout: r, _maxFreq: a, _minFreq: n, _mirror: o, _mode: l, _radial: h, _radialInvert: c, _reflexRatio: _ } = this, d = s.width >> 1, u = s.height >> 1, f = "dual-vertical" == r && !h, g = "dual-horizontal" == r, m = l % 10 != 0, p = m && "log" == this._frequencyScale, E = this._showLeds && m && !h, R = this._lumiBars && m && !h, A = this._alphaBars && !R && 10 != l, L = this._outlineBars && m && !R && !E, v = this._roundBars && m && !R && !E, w = "dual-vertical" != r || _ > 0 && !R, T = s.height - (f && !E ? .5 : 0) >> f, S = T * (R || h ? 1 : 1 - _) | 0, y = s.width - d * (g || 0 != o), C = f ? s.height - 2 * T : 0, b = d * (-1 == o && !g && !h); let O = .375 * Math.min(s.width, s.height) * ("dual-vertical" == r ? 1 : this._radius) | 0, I = Math.min(d, u); c && "dual-vertical" != r && ([O, I] = [I, O]); const x = e => t.push({ ...e, peak: [0, 0], hold: [0], value: [0] }), N = t => { const e = this._freqToBin(t, "floor"), i = this._binToFreq(e), s = this._binToFreq(e + 1); return [e, Math.log2(t / i) / Math.log2(s / i)] }; let B, F, M; if (p) { const i = (t, e, i) => +t.toPrecision(i ? Math.max(e, 1 + Math.log10(t) | 0) : e), s = t => { const e = [1, 1.12, 1.25, 1.4, 1.6, 1.8, 2, 2.24, 2.5, 2.8, 3.15, 3.55, 4, 4.5, 5, 5.6, 6.3, 7.1, 8, 9, 10], i = 0 | Math.log10(t), s = t / 10 ** i; let r = 1; for (; r < e.length && s > e[r];)r++; return s - e[r - 1] < e[r] - s && r--, (e[r] * 10 ** (i + 5) | 0) / 1e5 }, r = [0, 24, 12, 8, 6, 4, 3, 2, 1][l], o = e ? 10 ** (3 / (10 * r)) : 2 ** (1 / r), h = o ** .5; let c = e ? 7.94328235 / (r % 2 ? 1 : h) : C_1; do { let t = c; const a = i(t / h, 4, !0), l = i(t * h, 4, !0), [_, d] = N(a), [u, f] = N(l); t = e ? r < 4 ? s(t) : i(t, t.toString()[0] < 5 ? 3 : 2) : i(t, 4, !0), t >= n && x({ posX: 0, freq: t, freqLo: a, freqHi: l, binLo: _, binHi: u, ratioLo: d, ratioHi: f }), c *= o } while (c <= a); B = y / t.length, t.forEach(((t, e) => t.posX = b + e * B)); const _ = t[0], d = t[t.length - 1]; F = this._freqScaling(_.freqLo), M = y / (this._freqScaling(d.freqHi) - F), _.freqLo < n && (_.freqLo = n, [_.binLo, _.ratioLo] = N(n)), d.freqHi > a && (d.freqHi = a, [d.binHi, d.ratioHi] = N(a)) } else if (m) { const t = 10 * [0, 24, 12, 8, 6, 4, 3, 2, 1][l], e = t => { switch (this._frequencyScale) { case "bark": return 1960 / (26.81 / (t + .53) - 1); case "mel": return 700 * (2 ** t - 1); case "linear": return t } }; B = y / t, F = this._freqScaling(n), M = y / (this._freqScaling(a) - F); for (let i = 0, s = 0; i < t; i++, s += B) { const t = e(F + s / M), i = e(F + (s + B / 2) / M), r = e(F + (s + B) / M), [a, n] = N(t), [o, l] = N(r); x({ posX: b + s, freq: i, freqLo: t, freqHi: r, binLo: a, binHi: o, ratioLo: n, ratioHi: l }) } } else { B = 1, F = this._freqScaling(n), M = y / (this._freqScaling(a) - F); const e = this._freqToBin(n, "floor"), i = this._freqToBin(a); let s = -999; for (let r = e; r <= i; r++) { const e = this._binToFreq(r), i = b + Math.round(M * (this._freqScaling(e) - F)); if (i > s) x({ posX: i, freq: e, freqLo: e, freqHi: e, binLo: r, binHi: r, ratioLo: 0, ratioHi: 0 }), s = i; else if (t.length) { const i = t[t.length - 1]; i.binHi = r, i.freqHi = e, i.freq = (i.freqLo * e) ** .5 } } } let D = 0, G = 0; if (E) { const t = this._pixelRatio / (window.devicePixelRatio > 1 && window.screen.height <= 540 ? 2 : 1), e = [[], [128, 3, .45], [128, 4, .225], [96, 6, .225], [80, 6, .225], [80, 6, .125], [64, 6, .125], [48, 8, .125], [24, 16, .125]], i = this._ledParams, [s, r, a] = i || e[l]; let n, o = S; if (i) { const e = 2 * t; let i; n = s + 1; do { n--, i = o / n / (1 + r), G = i * r } while ((i < e || G < e) && n > 1) } else { const e = 540 / r; G = Math.min(r * t, Math.max(2, o / e + .1 | 0)) } w && (o += G), i || (n = Math.min(s, o / (2 * G) | 0)), D = a >= 1 ? a : B * a, this._leds = [n, D, G, o / n - G] } const q = Math.min(B - 1, i * (i > 0 && i < 1 ? B : 1)); m && (B -= Math.max(E ? D : 0, q)), t.forEach(((e, s) => { let r = e.posX, a = B; m && (0 != i || E ? r += Math.max(E ? D : 0, q) / 2 : (r |= 0, a |= 0, s > 0 && r > t[s - 1].posX + t[s - 1].width && (r--, a++)), e.posX = r), e.barCenter = r + (1 == B ? 0 : a / 2), e.width = a })); const k = []; for (const t of [0, 1]) { const e = "dual-vertical" == r ? (T + C) * t : 0, i = e + T, s = e + S - (!E || w ? 0 : G); k.push({ channelTop: e, channelBottom: i, analyzerBottom: s }) } this._aux = { analyzerHeight: S, analyzerWidth: y, centerX: d, centerY: u, channelCoords: k, channelHeight: T, channelGap: C, initialX: b, innerRadius: O, outerRadius: I, scaleMin: F, unitWidth: M }, this._flg = { isAlpha: A, isBands: m, isLeds: E, isLumi: R, isOctaves: p, isOutline: L, isRound: v, noLedGap: w }, this._createScales() } _createScales() { if (!this._ready) return; const { analyzerWidth: t, initialX: e, innerRadius: i, scaleMin: s, unitWidth: r } = this._aux, { canvas: a, _frequencyScale: n, _mirror: o, _noteLabels: l, _radial: h, _scaleX: c, _scaleR: _ } = this, d = c.canvas, u = _.canvas, f = [], g = "dual-horizontal" == this._chLayout, m = "dual-vertical" == this._chLayout, p = Math.min(a.width, a.height), E = ["C", , "D", , "E", "F", , "G", , "A", , "B"], R = p / 34 | 0, A = d.height >> 1, L = R >> 1, v = A * (l ? .7 : 1.5), w = L * (l ? 1 : 2); if (l || !this._ansiBands && "log" == n) { let t = C_1; for (let e = -1; e < 11; e++)for (let i = 0; i < 12; i++) { if (t >= this._minFreq && t <= this._maxFreq) { const s = E[i], r = "C" == s; (s && l && !o && !g || r) && f.push(l ? [t, s + (r ? e : "")] : t) } t *= 1.0594630943592953 } } else f.push(16, 31.5, 63, 125, 250, 500, 1e3, 2e3, 4e3), "linear" == n ? f.push(6e3, 8e3, 1e4, 12e3, 14e3, 16e3, 18e3, 2e4, 22e3) : f.push(8e3, 16e3); u.width = u.height = Math.max(.15 * p, (i << 1) + m * R); const T = u.width >> 1, S = T - .7 * R, y = (t, e) => { const i = TAU * (t / a.width), s = i - HALF_PI, r = S * Math.cos(s), n = S * Math.sin(s); _.save(), _.translate(T + r, T + n), _.rotate(i), _.fillText(e, 0, 0), _.restore() }; d.width |= 0, c.fillStyle = _.strokeStyle = "#000c", c.fillRect(0, 0, d.width, d.height), _.arc(T, T, T - R / 2, 0, TAU), _.lineWidth = R, _.stroke(), c.fillStyle = _.fillStyle = "#fff", c.font = `${A}px ${FONT_FAMILY}`, _.font = `${L}px ${FONT_FAMILY}`, c.textAlign = _.textAlign = "center"; let C = -v / 4, b = -w; for (const i of f) { const [u, f] = Array.isArray(i) ? i : [i, i < 1e3 ? 0 | i : (i / 100 | 0) / 10 + "k"], p = r * (this._freqScaling(u) - s), E = .75 * d.height, R = "C" == f[0], L = A * (!l || o || g ? 3 : R ? 1.2 : .6); if (c.fillStyle = _.fillStyle = !R || o || g ? "#fff" : "#4f4", l) { const t = "log" == n, e = "linear" == n; let i = ["C"]; if ((t || u > 2e3 || !e && u > 250 || (!h || m) && (!e && u > 125 || u > 1e3)) && i.push("G"), (t || u > 4e3 || !e && u > 500 || (!h || m) && (!e && u > 250 || u > 2e3)) && i.push("E"), (e && u > 4e3 || (!h || m) && (t || u > 2e3 || !e && u > 500)) && i.push("D", "F", "A", "B"), !i.includes(f[0])) continue } p >= C + v / 2 && p <= t && (c.fillText(f, g && -1 == o ? t - p : e + p, E, L), (g || o && (p > v || 1 == o)) && c.fillText(f, g && 1 != o ? t + p : (e || a.width) - p, E, L), C = p + Math.min(L, c.measureText(f).width) / 2), p >= b + w && p < t - w && (y(g && 1 == o ? t - p : p, f), (g || o && (p > w || 1 == o)) && y(g && -1 != o ? t + p : -p, f), b = p) } } _draw(t) { this._runId = requestAnimationFrame((t => this._draw(t))); const e = t - this._time, i = t - this._last, s = this._maxFPS ? 975 / this._maxFPS : 0; if (i < s) return; this._last = t - (s ? i % s : 0), this._frames++, e >= 1e3 && (this._fps = this._frames / e * 1e3, this._frames = 0, this._time = t); const { isAlpha: r, isBands: a, isLeds: n, isLumi: o, isOctaves: l, isOutline: h, isRound: c, noLedGap: _ } = this._flg, { analyzerHeight: d, centerX: u, centerY: f, channelCoords: g, channelHeight: m, channelGap: p, initialX: E, innerRadius: R, outerRadius: A } = this._aux, { _bars: L, canvas: v, _canvasGradients: w, _chLayout: T, _colorMode: S, _ctx: y, _energy: C, fillAlpha: b, _fps: O, _linearAmplitude: I, _lineWidth: x, maxDecibels: N, minDecibels: B, _mirror: F, _mode: M, overlay: D, _radial: G, showBgColor: q, showPeaks: k, useCanvas: z, _weightingFilter: H } = this, P = this._scaleX.canvas, U = this._scaleR.canvas, X = O >> 1, W = "dual-combined" == T, V = "dual-horizontal" == T, Y = "dual-vertical" == T, $ = "single" == T, K = n && this._trueLeds && "gradient" == S, j = G ? v.width : this._aux.analyzerWidth, Q = E + j, J = k && this._peakLine && 10 == M, Z = G ? A - R : d, [tt, et, it, st] = this._leds || []; C.val > 0 && O > 0 && (this._spinAngle += this._spinSpeed * TAU / 60 / O); const rt = t => { if (this._reflexRatio > 0 && !o && !G) { let e, i; this.reflexFit || Y ? (e = Y && 0 == t ? m + p : 0, i = m - d) : (e = v.height - 2 * d, i = d), y.save(), y.globalAlpha = this.reflexAlpha, 1 != this.reflexBright && (y.filter = `brightness(${this.reflexBright})`), y.setTransform(1, 0, 0, -1, 0, v.height), y.drawImage(v, 0, g[t].channelTop, v.width, d, 0, e, v.width, i), y.restore() } }, at = () => { this.showScaleX && (G ? (y.save(), y.translate(u, f), this._spinSpeed && y.rotate(this._spinAngle + HALF_PI), y.drawImage(U, -U.width >> 1, -U.width >> 1), y.restore()) : y.drawImage(P, 0, v.height - P.height)) }, nt = t => { const e = t ** 2, i = 424.36, s = 148693636, r = t => 20 * Math.log10(t); switch (H) { case "A": return 2 + r(s * e ** 2 / ((e + i) * Math.sqrt((e + 11599.29) * (e + 544496.41)) * (e + s))); case "B": return .17 + r(s * e * t / ((e + i) * Math.sqrt(e + 25122.25) * (e + s))); case "C": return .06 + r(s * e / ((e + i) * (e + s))); case "D": const a = ((1037918.48 - e) ** 2 + 1080768.16 * e) / ((9837328 - e) ** 2 + 11723776 * e); return r(t / 68966888496476e-18 * Math.sqrt(a / ((e + 79919.29) * (e + 1345600)))); case "468": const n = -4737338981378384e-39 * t ** 6 + 2043828333606125e-30 * t ** 4 - 1.363894795463638e-7 * e + 1, o = 1306612257412824e-34 * t ** 5 - 2118150887518656e-26 * t ** 3 + .0005559488023498642 * t; return 18.2 + r(.0001246332637532143 * t / Math.hypot(n, o)) }return 0 }, ot = (t, e, i) => { y.beginPath(), y.moveTo(t, e), y.lineTo(t, i), y.stroke() }, lt = t => { if (t && x) { const t = y.globalAlpha; y.globalAlpha = 1, y.stroke(), y.globalAlpha = t } }, ht = t => Math.max(0, (t * tt | 0) * (st + it) - it); D && y.clearRect(0, 0, v.width, v.height); let ct = 0; const _t = L.length, dt = $ ? 1 : 2; for (let t = 0; t < dt; t++) { const { channelTop: e, channelBottom: i, analyzerBottom: s } = g[t], a = this._gradients[this._selectedGrads[t]], l = a.colorStops, _ = l.length, A = !q || n && !D ? "#000" : a.bgColor, T = Y && G && t ? -1 : 1, C = !t && -1 == F || t && 1 == F, O = !V || t && 1 != F ? 0 : j >> (t || !C), U = V && C ? -1 : 1, $ = () => { const i = P.height, s = i >> 1, r = I ? 100 : N, a = I ? 0 : B, n = I ? 20 : 5, o = d / (r - a), l = -1 != F && (!V || 0 == t || 1 == F), h = 1 != F && (!V || t != F); y.save(), y.fillStyle = "#888", y.font = `${s}px ${FONT_FAMILY}`, y.textAlign = "right", y.lineWidth = 1; for (let t = r; t > a; t -= n) { const a = e + (r - t) * o, n = t % 2 == 0 | 0; if (n) { const r = a + s * (a == e ? .8 : .35); l && y.fillText(t, .85 * i, r), h && y.fillText(t, (V ? j : v.width) - .1 * i, r), y.strokeStyle = "#888", y.setLineDash([2, 4]), y.lineDashOffset = 0 } else y.strokeStyle = "#555", y.setLineDash([2, 8]), y.lineDashOffset = 1; y.beginPath(), y.moveTo(E + i * n * l, .5 + ~~a), y.lineTo(Q - i * n * h, .5 + ~~a), y.stroke() } y.restore() }, tt = (t, e) => { const i = ft[t] + (t < ft.length - 1 ? (ft[t + 1] - ft[t]) * e : 0); return isNaN(i) ? -1 / 0 : i }, et = (t, e = U) => e * TAU * ((t + O) / v.width) + this._spinAngle, at = (t, e, i) => { const s = R + e * T, r = et(t, i); return [u + s * Math.cos(r), f + s * Math.sin(r)] }, dt = (t, e, i, s, r) => { y.beginPath(); for (const a of F && !V ? [1, -1] : [U]) { const [n, o] = c ? [et(t, a), et(t + i, a)] : []; y.moveTo(...at(t, e, a)), y.lineTo(...at(t, e + s, a)), c ? y.arc(u, f, R + (e + s) * T, n, o, 1 != a) : y.lineTo(...at(t + i, e + s, a)), y.lineTo(...at(t + i, e, a)), c && !r && y.arc(u, f, R + e * T, o, n, 1 == a) } lt(r), y.fill() }, ut = (e = 0, i = 0) => { let s; if ("gradient" == S && !K || 10 == M) s = w[t]; else { const t = "bar-index" == S ? i % _ : l.findLastIndex((t => n ? ht(e) <= ht(t.level) : e <= t.level)); s = l[t].color } y.fillStyle = y.strokeStyle = s }; if (z) { if (V && !G) { const e = j * (t + C), i = C ? -1 : 1; y.setTransform(i, 0, 0, 1, e, 0) } if (D && !q || (D && (y.globalAlpha = this.bgAlpha), y.fillStyle = A, 0 != t && (G || W) || y.fillRect(E, e - p, j, (D && 1 == this.reflexAlpha ? d : m) + p), y.globalAlpha = 1), !this.showScaleY || o || G || 0 != t && W || $(), n ? (y.setLineDash([st, it]), y.lineWidth = L[0].width) : y.lineWidth = h ? Math.min(x, L[0].width / 2) : x, y.save(), !G) { const t = new Path2D; t.rect(0, e, v.width, d), y.clip(t) } } let ft = this._fftData[t]; this._analyzer[t].getFloatFrequencyData(ft), H && (ft = ft.map(((t, e) => t + nt(this._binToFreq(e))))), y.beginPath(); let gt = []; for (let i = 0; i < _t; i++) { const a = L[i], { posX: d, barCenter: u, width: f, freq: g, binLo: m, binHi: p, ratioLo: A, ratioHi: v } = a; let w = Math.max(tt(m, A), tt(p, v)); for (let t = m + 1; t < p; t++)ft[t] > w && (w = ft[t]); if (w = this._normalizedB(w), a.value[t] = w, ct += w, a.peak[t] > 0 && (a.hold[t]--, a.hold[t] < 0 && (a.peak[t] += a.hold[t] / (X * X / 2))), w >= a.peak[t] && (a.peak[t] = w, a.hold[t] = X), !z) continue; o || r ? y.globalAlpha = w : h && (y.globalAlpha = b), ut(w, i); const T = o ? Z : n ? ht(w) : w * Z | 0; if (10 == M) { const t = i ? 0 : (this._normalizedB(ft[L[1].binLo]) * Z + T) / 2; if (G) { if (0 == i && (V && y.moveTo(...at(0, 0)), y.lineTo(...at(0, d < 0 ? t : T))), d >= 0) { const t = [d, T]; y.lineTo(...at(...t)), gt.push(t) } } else { if (0 == i) if (-1 != F || V) { const t = m ? this._normalizedB(ft[m - 1]) * Z : T; y.moveTo(E - x, s - t) } else y.moveTo(E, s - (d < E ? t : T)); (V || -1 != F || d >= E) && y.lineTo(d, s - T) } } else if (n) { if (q && !D && (0 == t || !W)) { const t = y.globalAlpha; y.strokeStyle = "#7f7f7f22", y.globalAlpha = 1, ot(u, e, s), y.strokeStyle = y.fillStyle, y.globalAlpha = t } if (K) { const t = o ? 0 : l.findLastIndex((t => ht(w) <= ht(t.level))); let e = s; for (let i = _ - 1; i >= t; i--) { y.strokeStyle = l[i].color; let r = s - (i == t ? T : ht(l[i].level)); ot(u, e, r), e = r - it } } else ot(u, s, s - T) } else if (d >= E) if (G) dt(d, 0, f, T, h); else if (c) { const t = f / 2, e = s + t; y.beginPath(), y.moveTo(d, e), y.lineTo(d, e - T), y.arc(u, e - T, t, PI, TAU), y.lineTo(d + f, e), lt(h), y.fill() } else { const t = h ? y.lineWidth : 0; y.beginPath(), y.rect(d, s + t, f, -T - t), lt(h), y.fill() } const C = a.peak[t]; if (C > 0 && k && !J && !o && d >= E && d < Q) if (h && x > 0 ? y.globalAlpha = 1 : r && (y.globalAlpha = C), ("bar-level" == S || K) && ut(C), n) { const t = ht(C); t >= it && y.fillRect(d, s - t, f, st) } else if (G) { if (10 != M) { const t = C * Z; dt(d, t, f, !this._radialInvert || Y || t + R >= 2 ? -2 : 2) } } else y.fillRect(d, s - C * Z, f, 2) } if (z) { if (y.globalAlpha = 1, 10 == M) { if (ut(), G && !V) { if (F) { let t; for (; t = gt.pop();)y.lineTo(...at(...t, -1)) } y.closePath() } if (x > 0 && y.stroke(), b > 0) { if (G) { const t = V ? et(j >> 1) : 0, e = V ? et(j) : TAU; y.moveTo(...at(V ? j >> 1 : 0, 0)), y.arc(u, f, R, t, e, !V || !C) } else y.lineTo(Q, s), y.lineTo(E, s); y.globalAlpha = b, y.fill(), y.globalAlpha = 1 } if ((J || G && k) && (gt = [], y.beginPath(), L.forEach(((e, i) => { let r = e.posX, a = e.peak[t], n = i ? "lineTo" : "moveTo"; if (G && r < 0) { const e = L[i + 1]; a = findY(r, a, e.posX, e.peak[t], 0), r = 0 } a *= Z, J ? (y[n](...G ? at(r, a) : [r, s - a]), G && F && !V && gt.push([r, a])) : a > 0 && dt(r, a, 1, -2) })), J)) { let t; for (; t = gt.pop();)y.lineTo(...at(...t, -1)); y.lineWidth = 1, y.stroke() } } y.restore(), V && !G && y.setTransform(1, 0, 0, 1, 0, 0), (!V && !W || t) && rt(t) } } var ut; if (ut = ct / (_t << dt - 1), C.val = ut, C.peak > 0 && (C.hold--, C.hold < 0 && (C.peak += C.hold / (X * X / 2))), ut >= C.peak && (C.peak = ut, C.hold = X), z && (!F || G || V || (y.setTransform(-1, 0, 0, 1, v.width - E, 0), y.drawImage(v, E, 0, u, v.height, 0, 0, u, v.height), y.setTransform(1, 0, 0, 1, 0, 0)), y.setLineDash([]), at()), this.showFPS) { const t = P.height; y.font = `bold ${t}px ${FONT_FAMILY}`, y.fillStyle = "#0f0", y.textAlign = "right", y.fillText(Math.round(O), v.width - t, 2 * t) } this.onCanvasDraw && (y.save(), y.fillStyle = y.strokeStyle = w[0], this.onCanvasDraw(this, { timestamp: t, canvasGradients: w }), y.restore()) } _freqScaling(t) { switch (this._frequencyScale) { case "log": return Math.log2(t); case "bark": return 26.81 * t / (1960 + t) - .53; case "mel": return Math.log2(1 + t / 700); case "linear": return t } } _freqToBin(t, e = "round") { const i = this._analyzer[0].frequencyBinCount - 1, s = Math[e](t * this.fftSize / this.audioCtx.sampleRate); return s < i ? s : i } _makeGrad() { if (!this._ready) return; const { canvas: t, _ctx: e, _radial: i, _reflexRatio: s } = this, { analyzerWidth: r, centerX: a, centerY: n, initialX: o, innerRadius: l, outerRadius: h } = this._aux, { isLumi: c } = this._flg, _ = "dual-vertical" == this._chLayout, d = 1 - s, u = c ? t.height : t.height * (1 - s * !_) | 0; for (const t of [0, 1]) { const f = this._gradients[this._selectedGrads[t]], g = f.colorStops, m = "h" == f.dir; let p; if (p = i ? e.createRadialGradient(a, n, h, a, n, l - (h - l) * _) : e.createLinearGradient(...m ? [o, 0, o + r, 0] : [0, 0, 0, u]), g) { const t = _ && !this._splitGradient && (!m || i); for (let e = 0; e < 1 + t; e++) { const r = g.length - 1; g.forEach(((a, n) => { let o = a.pos; if (t && (o /= 2), !_ || c || i || m || (o *= d, !t && o > .5 * d && (o += .5 * s)), 1 == e) if (i || c) { o = 1 - (a = g[r - n]).pos / 2 } else 0 == n && o > 0 && p.addColorStop(.5, a.color), o += .5; p.addColorStop(o, a.color), _ && n == r && o < .5 && p.addColorStop(.5, a.color) })) } } this._canvasGradients[t] = p } } _normalizedB(t) { const e = this._linearAmplitude, i = e ? 1 / this._linearBoost : 1, s = t => 10 ** (t / 20); let r = this.maxDecibels, a = this.minDecibels; return e && (r = s(r), a = s(a), t = s(t) ** i), l = 1, (n = (t - a) / (r - a) ** i) <= (o = 0) ? o : n >= l ? l : n; var n, o, l } _setCanvas(t) { if (!this._ready) return; const { canvas: e, _ctx: i } = this, s = this._scaleX.canvas, r = window.devicePixelRatio / (this._loRes + 1); let a = window.screen.width * r, n = window.screen.height * r; 90 == Math.abs(window.orientation) && a < n && ([a, n] = [n, a]); const o = this.isFullscreen, l = o && this._fsEl == e, h = l ? a : (this._width || this._container.clientWidth || this._defaultWidth) * r | 0, c = l ? n : (this._height || this._container.clientHeight || this._defaultHeight) * r | 0; this._pixelRatio = r, this._fsWidth = a, this._fsHeight = n, "create" != t && e.width == h && e.height == c || (e.width = h, e.height = c, this.overlay || (i.fillStyle = "#000", i.fillRect(0, 0, h, c)), i.lineJoin = "bevel", s.width = h, s.height = Math.max(20 * r, Math.min(h, c) / 32 | 0), this._calcBars(), this._makeGrad(), void 0 !== this._fsStatus && this._fsStatus !== o && (t = "fschange"), this._fsStatus = o, this.onCanvasResize && this.onCanvasResize(t, this)) } _setGradient(t, e) { if (!this._gradients.hasOwnProperty(t)) throw new AudioMotionError(ERR_UNKNOWN_GRADIENT, t);[0, 1].includes(e) || (this._selectedGrads[1] = t, e = 0), this._selectedGrads[e] = t, this._makeGrad() } _setProps(t, e) { const i = ["onCanvasDraw", "onCanvasResize"], s = Object.keys(DEFAULT_SETTINGS).filter((t => "start" != t)).concat(i, ["gradientLeft", "gradientRight", "stereo"]); (e || void 0 === t) && (t = { ...DEFAULT_SETTINGS, ...t }); for (const e of Object.keys(t)) i.includes(e) && "function" != typeof t[e] ? this[e] = void 0 : s.includes(e) && (this[e] = t[e]); void 0 !== t.start && this.toggleAnalyzer(t.start) } }
